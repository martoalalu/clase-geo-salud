---
title: "Geocodificando y capas base"
subtitle: "Analisis espacial con R"
author: "Bourdin Elian"
date: "19/7/2021"
output: 
  html_document:
    fig_height: 8
    fig_width: 12
    #code_folding: "hide"
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r , echo=TRUE, message=FALSE, warning=FALSE}
#library (tmaptools)
detach("package:tmaptools", unload=TRUE)
library (RUMBA)
library (tidyverse)
library (sf)
library (ggmap)
```


# Geocodificando

Pero... qué es geocodificar?

Es el proceso de asignar coordenadas (ergo, localización espacial) a uno o varios atributos alfanuméricos que constituyen una dirección. Se requiere de 4 argumentos fundamentales para ello: Calle, Altura o número, Localidad y Estado o Provincia. Otros atributos mejoran la calidad y la precisión: Barrio, País, Código Postal, etc.

Para geocodificar hacemos uso de APIs y servicios geográficos, en este caso, veremos cómo usar el de OpenStreetMap o también conocido como OSM (Nominatim)

## OpenStreetMap

[**OpenStreetMap**](https://www.openstreetmap.org/) es un proyecto colaborativo para crear mapas editables y libres. Los mapas se crean utilizando información geográfica capturada con dispositivos GPS móviles, ortofotografías y otras fuentes libres. Esta cartografía, tanto las imágenes creadas como los datos vectoriales almacenados en su base de datos, se distribuye bajo licencia abierta Licencia Abierta de Bases de Datos.

Los contribuidores más entusiastas mapean barrios completos utilizando herramientas GPS para enviar información local completa, actualizada y precisa a OpenStreetMap. Varias empresas y entidades públicas que producen información geográfica también contribuyen al permitir que sus datos sean incluidos. Existen equipos profesionales de contribuidores que se coordinan para agregar y mantener actualizada información georeferenciada de límites políticos, calles, edificios, negocios y otros puntos de interés.

Toda la información disponible en OpenStreetMap puede ser descargada y reutilizada por cualquier persona, ya sea accediendo al mapa online, obteniendo una copia completa de la base de datos, o accediendo a los datos vía API.

Empecemos!

Vamos a trabajar con datos de una base de datos de entros de salud municipales de Cordoba capital.



```{r}
Centros_Salud <- read_csv("https://raw.githubusercontent.com/martoalalu/clase-geo-salud/clase-2021/data/centros_salud.csv")

#vamos a explorar el objeto
head (Centros_Salud)
summary(Centros_Salud)

#cuántos valores nulos tenemos en los datos de dirección?
sum(is.na(Centros_Salud$Calle))
sum(is.na(Centros_Salud$Altura)) #Tenemos varios valores nulos
```

Para acceder a las funcionalidades de la API usaremos la libería tmaptools, que tiene una amplia funcionalidad, entre ellas, conectarse a los servicios de OSM.

```{r}
# primero tenemos que construir el campo de dirección tal como lo requerimos
Centros_Salud_Direccion <- Centros_Salud %>% 
  mutate(DirCompleta = paste(Calle, Altura, ",", Localidad, ", Argentina"))

#vamos a explorar el objeto
head(Centros_Salud_Direccion)
summary(Centros_Salud_Direccion)

#cuántas direcciones tenemos?
nrow (Centros_Salud_Direccion)
```

Vamos a geocodificar nuestras direcciones

```{r, warning=FALSE, message=FALSE}
Centros_Salud_Direccion <- Centros_Salud_Direccion %>% 
  mutate(geo=geocode_OSM(  #me devuelve las coordenadas (geocode_OSM) en un campo adicional a los originales
    Centros_Salud_Direccion$DirCompleta,  
    return.first.only = TRUE,  # me devuelve solo el primer resultado encontrado
    keep.unfound = TRUE,  # que mantenga aquellas direcciones que No pudo geolocalizar, con un null en el campo "geo"
    details = FALSE, # que no devuelva detalles, id de OSM u objetos cercanos
    #as.data.frame = NA,
    as.sf = FALSE, # que lo deje como una tabla y no lo convierta en un spatial frame
    geometry = "point", # que la geometría sea de tipo PUNTO (es decir, un par de coordenadas)
    server = "https://nominatim.openstreetmap.org" # el servicio que deseo usar: Nominatim
  ))

#qué obtuvimos?
head(Centros_Salud_Direccion)
summary (Centros_Salud_Direccion$geo) #vamos a explorar el componente geo del objeto que nos devuelve OSM

# Base final con coordenadas
Centros_Salud_Direccion <- Centros_Salud_Direccion %>% 
  mutate(lon=geo$lon, lat = geo$lat) %>% # el campo geo se arma como lista, tenemos que seleccionar una lon y una lat
  select(`Centro de Salud`, DirCompleta, lon, lat)

#exploremos el objeto final...
summary (Centros_Salud_Direccion)


#qué nos falta para que sea un objeto geográfico? Agregar el sistema de referencia!
Centros_Salud_Direccion <- Centros_Salud_Direccion %>% 
  filter(!is.na(lon), !is.na(lat)) %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326)


summary (Centros_Salud_Direccion)
class(Centros_Salud_Direccion)

```


## USIG

Hay otros servicios para trabajar datos!

USIG es la Unidad de Sistemas de Información Geográfica del Gobierno de la Ciudad de Buenos Aires y brinda un servicio de geocodificación (entre otras cosas) de datos de la Ciudad de Buenos Aires de manera gratuita!!!

La librería que nos facilita el uso de este servicio se llama RUMBA, la cual la instalamos con el clásico install.packages("RUMBA").

RUMBA es un conjunto de herramientas para el análisis de la Región Urbana Metropolitana de Buenos Aires usando R. Incluye funciones que permiten obtener coordenadas precisas (longitud y latitud) que corresponden a direcciones dentro de los límites de la Región Urbana Metropolitana de Buenos Aires o bien de barrios vulnerables de la Ciudad de Buenos Aires.

Las funciones consultan la API del Normalizador de direcciones y de Déficit Habitacional de la USIG. Ademas de las coordenadas, se obtiene la dirección normalizada (escrita de forma inequívoca).

Les proponemos hacer un ejercicio con las postas de vacunación de CABA

```{r}
Postas_Vacunacion <-  readxl::read_xlsx("clase-geo-salud/data/postas_vacunacion_covid.xlsx")


#vamos a explorar el objeto
head(Postas_Vacunacion)
summary(Postas_Vacunacion)

nrow(Postas_Vacunacion)
```

El dataframe tiene una columna que hace referencia a la dirección de los centros de vacunación. Pero no tenemos ni latitud ni longitud. Ya sabemos que podemos geocodificar los datos! Vamos a probar el servicio de la USIG.

Con la función *mutate_USIG_geocode* podemos agregar las columnas de lon y lat y así tener las coordenadas. La dirección debe estar expresada como “calle altura, partido”, “calle altura, municipio”, “calle y calle, partido”, o “calle altura, municipio”. El partido o municipio son opcionales. De no ser aclarados, y encontrarse múltiples direcciones que coincidan con la búsqueda, se entregaran las coordenadas dentro de la Ciudad Autónoma de Buenos Aires (si existieran), o en su defecto las del primer partido -por orden alfabético- donde se haya encontrado la dirección.

En resumen: es mejor incluir partido o municipio en las direcciones a georeferenciar.

```{r, message=FALSE}
Postas_Vacunacion_Direccion <- mutate_USIG_geocode(Postas_Vacunacion, "direccion") #paciencia. Puede tardar un poco! Utilizar la función es tan simple como indicar el DF y el nombre del campo que tiene la dirección que vamos a trabajar.

USIG_geocode(c("9 de Julio y Belgrano, Temperley", "Callao y Corrientes", "Anchorena 1210, La Lucila"))

#vamos a explorar el objeto
head(Postas_Vacunacion_Direccion)
summary(Postas_Vacunacion_Direccion)

#Solo nos queda transformarlo a objeto geográfico
Postas_Vacunacion_Direccion <- Postas_Vacunacion_Direccion %>% 
  filter(!is.na(lon), !is.na(lat)) %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326)


summary (Postas_Vacunacion_Direccion)
class(Postas_Vacunacion_Direccion)
```


# Agregando contexto a la información

Pudimos geolocalizar gran parte de nuestras direcciones de interés, aunque ya vimos que no es un proceso infalible... pero cuando trabajamos con datos gegráficos es importante poder tener una referencia, ubicar los puntos en contexto, pero ¿Qué pasa cuando no tenemos un mapa?

Tenemos una opción! Podemos agregar capas base, que sería como agregar "una foto" sobre la cual posicionaremos los datos de interés. 

El primer paso para obtener las capas bases que necesitamos es obtener el *bounding box* del mapa que queremos descargar. ¿Qué utilizamos?... así es! *getbb*. En este caso obtendremos un mapa de la Ciudad Autónoma de Buenos Aires, ya que vamos a localizar las Postas de Vacunación que geocodificamos en el paso anterior.
 
```{r}
bbox <- getbb("Ciudad Autónoma de Buenos Aires,Argentina")

head(bbox)
```

Ya tenemos los límites de la ciudad en la variable bbox. Ahora vamos a descargar la capa base utilizando *ggmap*. Lo que permite hacer ggmap es, en esencia, es añadir a los gráficos ya conocidos una capa cartográfica adicional. Para eso usa recursos disponibles en la web a través de APIs; ggmap tiene funciones para obtener mapas (de diversos tipos y de distintos orígenes: Google, Stamen, OpenStreetMap). Nosotros vamos a obtener un mapa de Stamen que es un estudio de visualización de datos que abre sus mapas para el uso de la comunidad. Pueden ver sus diferentes diseños en [**Stamen maps**](https://stamen.com/open-source/)

```{r, message=FALSE}
#Vamos a descargar el mapa

CABATerra <- get_stamenmap(bbox = bbox, #En bboxle indicamos los límites específicos, ya lo sabemos!
                      maptype = "terrain", #En maptype le indicamos el tipo de mapa que queremos descargarnos. 
                      zoom=13)#En zoom le indicamos el nivel de detalle que queremos. A más zoom, más detalle, pero también más pesado el archivo que nos descarguemos…

#que tenemos en la variable CABA?
head(CABATerra) #raro?
CABATerra #R ya nos dice en la descripción que estamos trabajando con una imagen de mapa de Stamen Maps... e incluso nos sugiere como graficarlo!!!
```

Vamos a hacerle caso a los consejos de R y vamos a utilizar *ggmap* para dibujar el mapa. Por suerte para nosotros, ggmap tiene la misma sintaxis que ggplot(), por lo tanto no tendremos demasiados inconvenientes.

```{r}

ggmap(CABATerra)

```

Y si probamos con otro tipo de mapa?

```{r, message=FALSE}
CABATonner <- get_stamenmap(bbox = bbox, 
                      maptype = "toner-background",  
                      zoom=13)

ggmap(CABATonner)
```

Excelente, tenemos nuestra capa de base, pero ahora cómo ubicamos en contexto las Postas de Vacunación de la Ciudad? Fácil... agregando una nueva capa a nuestro mapa!

```{r}
ggmap(CABATonner) +
  geom_sf(data=Postas_Vacunacion_Direccion, inherit.aes=FALSE, color = "red", size = 2)
```

¿Qué les parece el mapa que obtuvimos?...

# Haciendo mapas interactivos!

Hasta el momento hicimos siempre mapas estáticos (con o sin capa base) pero también podemos hacer que estos mapas sean interactivos, con posiiblidad de hacer zoom y ver información adicional!

Para eso vamos a usar la librería leaflet que básicamente es una [librería en Javascript](https://leafletjs.com/) para hacer mapas interactivos y que se llama igual, leaflet.

Vamos a usar datos de INDEC de NBI a nivel departamento que obtenemos de su geoservicio.

```{r}
library(leaflet)

baseurl <- "https://geoservicios.indec.gob.ar/geoserver/wfs?request=GetFeature&service=WFS&typeName="
capa_wfs <- "geocenso2010:nbi_dpto"

nbi_deptos <- st_read(paste0(baseurl,capa_wfs))
```

Genial, ahora que tenemos los datos vamos a hacer un choropleth con porcentaje de personas con nbi por departamento.

Al igual que con ggplot() a R le tenemos que avisar que vamos a hacer un mapa interactivo, por eso invocamos a "leaflet" luego necesitamos 3 componentes fundamentales:
 1. Setear dónde queremos que esté centrado el mapa y en qué nivel de zoom con **setView**
 2. Agregar la capa base con **addTiles**
 3. Agregar la geometría! Si es polígono con **addPolygons**, si son puntos es **addMarkers**.

```{r}

nbi_deptos <- st_cast(nbi_deptos, "GEOMETRYCOLLECTION") %>%  st_collection_extract("POLYGON")

library(viridisLite)
binpal <- colorBin("viridis", nbi_deptos$personas_con_nbi_porc, 8, pretty = FALSE)

leaflet() %>% 
  setView(lng = -58.446216, lat = -34.615766, zoom = 4) %>% 
  addTiles() %>% 
  addPolygons(data=nbi_deptos, stroke=FALSE, smoothFactor = 0.2, fillOpacity = .8,
    color = ~binpal(personas_con_nbi_porc),popup=paste(nbi_deptos$departamento,"% NBI:",nbi_deptos$personas_con_nbi_porc)) %>% 
  addProviderTiles(providers$CartoDB.Positron)
```

