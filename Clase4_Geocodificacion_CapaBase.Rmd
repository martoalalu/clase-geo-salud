---
title: "Geocodificando, capas base, mapas interactivos y ruteo"
subtitle: "Analisis espacial con R"
author: "Bourdin Elian"
date: "19/7/2021"
output: 
  html_document:
    fig_height: 8
    fig_width: 12
    #code_folding: "hide"
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r , echo=TRUE, message=FALSE, warning=FALSE}
library (tmaptools)
library (RUMBA)
library (tidyverse)
library (sf)
library (ggmap)
library(osmdata)
```


# Geocodificando con Open Street Map

Pero... qué es geocodificar?

Es el proceso de asignar coordenadas (ergo, localización espacial) a uno o varios atributos alfanuméricos que constituyen una dirección. Se requiere de 4 argumentos fundamentales para ello: Calle, Altura o número, Localidad y Estado o Provincia. Otros atributos mejoran la calidad y la precisión: Barrio, País, Código Postal, etc.

Para geocodificar hacemos uso de APIs y servicios geográficos, en este caso, veremos cómo usar el de OpenStreetMap o también conocido como OSM (Nominatim)

## OpenStreetMap

[**OpenStreetMap**](https://www.openstreetmap.org/) es un proyecto colaborativo para crear mapas editables y libres. Los mapas se crean utilizando información geográfica capturada con dispositivos GPS móviles, ortofotografías y otras fuentes libres. Esta cartografía, tanto las imágenes creadas como los datos vectoriales almacenados en su base de datos, se distribuye bajo licencia abierta Licencia Abierta de Bases de Datos.

Los contribuidores más entusiastas mapean barrios completos utilizando herramientas GPS para enviar información local completa, actualizada y precisa a OpenStreetMap. Varias empresas y entidades públicas que producen información geográfica también contribuyen al permitir que sus datos sean incluidos. Existen equipos profesionales de contribuidores que se coordinan para agregar y mantener actualizada información georeferenciada de límites políticos, calles, edificios, negocios y otros puntos de interés.

Toda la información disponible en OpenStreetMap puede ser descargada y reutilizada por cualquier persona, ya sea accediendo al mapa online, obteniendo una copia completa de la base de datos, o accediendo a los datos vía API.

Empecemos!

Vamos a trabajar con datos de una base de datos de entros de salud municipales de Cordoba capital.



```{r}
Centros_Salud <- read_csv("https://raw.githubusercontent.com/martoalalu/clase-geo-salud/clase-2021/data/centros_salud.csv")

#vamos a explorar el objeto
head (Centros_Salud)
summary(Centros_Salud)

#cuántos valores nulos tenemos en los datos de dirección?
sum(is.na(Centros_Salud$Calle))
sum(is.na(Centros_Salud$Altura)) #Tenemos varios valores nulos
```

Para acceder a las funcionalidades de la API usaremos la libería tmaptools, que tiene una amplia funcionalidad, entre ellas, conectarse a los servicios de OSM.

```{r}
# primero tenemos que construir el campo de dirección tal como lo requerimos
Centros_Salud_Direccion <- Centros_Salud %>% 
  mutate(DirCompleta = paste(Calle, Altura, ",", Localidad, ", Argentina"))

#vamos a explorar el objeto
head(Centros_Salud_Direccion)
summary(Centros_Salud_Direccion)

#cuántas direcciones tenemos?
nrow (Centros_Salud_Direccion)
```

Vamos a geocodificar nuestras direcciones

```{r, warning=FALSE, message=FALSE}
Centros_Salud_Direccion <- Centros_Salud_Direccion %>% 
  mutate(geo=geocode_OSM(  #me devuelve las coordenadas (geocode_OSM) en un campo adicional a los originales
    Centros_Salud_Direccion$DirCompleta,  
    return.first.only = TRUE,  # me devuelve solo el primer resultado encontrado
    keep.unfound = TRUE,  # que mantenga aquellas direcciones que No pudo geolocalizar, con un null en el campo "geo"
    details = FALSE, # que no devuelva detalles, id de OSM u objetos cercanos
    #as.data.frame = NA,
    as.sf = FALSE, # que lo deje como una tabla y no lo convierta en un spatial frame
    geometry = "point", # que la geometría sea de tipo PUNTO (es decir, un par de coordenadas)
    server = "https://nominatim.openstreetmap.org" # el servicio que deseo usar: Nominatim
  ))

#qué obtuvimos?
head(Centros_Salud_Direccion)
summary (Centros_Salud_Direccion$geo) #vamos a explorar el componente geo del objeto que nos devuelve OSM

# Base final con coordenadas
Centros_Salud_Direccion <- Centros_Salud_Direccion %>% 
  mutate(lon=geo$lon, lat = geo$lat) %>% # el campo geo se arma como lista, tenemos que seleccionar una lon y una lat
  select(`Centro de Salud`, DirCompleta, lon, lat)

#exploremos el objeto final...
summary (Centros_Salud_Direccion)


#qué nos falta para que sea un objeto geográfico? Agregar el sistema de referencia!
Centros_Salud_Direccion <- Centros_Salud_Direccion %>% 
  filter(!is.na(lon), !is.na(lat)) %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326)


summary (Centros_Salud_Direccion)
class(Centros_Salud_Direccion)

```



# Agregando contexto a la información

Pudimos geolocalizar gran parte de nuestras direcciones de interés, aunque ya vimos que no es un proceso infalible... pero cuando trabajamos con datos gegráficos es importante poder tener una referencia, ubicar los puntos en contexto, pero ¿Qué pasa cuando no tenemos un mapa?

Tenemos una opción! Podemos agregar capas base, que sería como agregar "una foto" sobre la cual posicionaremos los datos de interés. 

El primer paso para obtener las capas bases que necesitamos es obtener el *bounding box* del mapa que queremos descargar. ¿Qué utilizamos?... así es! *getbb*. En este caso obtendremos un mapa de la Ciudad Autónoma de Buenos Aires, ya que vamos a localizar las Postas de Vacunación que geocodificamos en el paso anterior.
 
```{r}
bbox <- getbb("Provincia de Córdoba, Argentina")

head(bbox)
```

Ya tenemos los límites de la ciudad en la variable bbox. Ahora vamos a descargar la capa base utilizando *ggmap*. Lo que permite hacer ggmap es, en esencia, es añadir a los gráficos ya conocidos una capa cartográfica adicional. Para eso usa recursos disponibles en la web a través de APIs; ggmap tiene funciones para obtener mapas (de diversos tipos y de distintos orígenes: Google, Stamen, OpenStreetMap). Nosotros vamos a obtener un mapa de Stamen que es un estudio de visualización de datos que abre sus mapas para el uso de la comunidad. Pueden ver sus diferentes diseños en [**Stamen maps**](https://stamen.com/open-source/)

```{r, message=FALSE}
#Vamos a descargar el mapa

cbaTerra <- get_stamenmap(bbox = bbox, #En bboxle indicamos los límites específicos, ya lo sabemos!
                      maptype = "terrain", #En maptype le indicamos el tipo de mapa que queremos descargarnos. 
                      zoom=8)#En zoom le indicamos el nivel de detalle que queremos. A más zoom, más detalle, pero también más pesado el archivo que nos descarguemos…

#que tenemos en la variable CABA?
head(cbaTerra) #raro?
cbaTerra #R ya nos dice en la descripción que estamos trabajando con una imagen de mapa de Stamen Maps... e incluso nos sugiere como graficarlo!!!
```

Vamos a hacerle caso a los consejos de R y vamos a utilizar *ggmap* para dibujar el mapa. Por suerte para nosotros, ggmap tiene la misma sintaxis que ggplot(), por lo tanto no tendremos demasiados inconvenientes.

```{r}

ggmap(cbaTerra)

```

Y si probamos con otro tipo de mapa?

```{r, message=FALSE}
cbaTonner <- get_stamenmap(bbox = bbox, 
                      maptype = "toner-background",  
                      zoom=8)

ggmap(cbaTonner)
```

Excelente, tenemos nuestra capa de base, pero ahora cómo ubicamos en contexto los Centros de Salud? Fácil... agregando una nueva capa a nuestro mapa!

```{r}
ggmap(cbaTonner) +
  geom_sf(data=Centros_Salud_Direccion, inherit.aes=FALSE, color = "red", size = 1)
```

¿Qué les parece el mapa que obtuvimos?...

# Haciendo mapas interactivos!

Hasta el momento hicimos siempre mapas estáticos (con o sin capa base) pero también podemos hacer que estos mapas sean interactivos, con posiiblidad de hacer zoom y ver información adicional!

Para eso vamos a usar la librería leaflet que básicamente es una [librería en Javascript](https://leafletjs.com/) para hacer mapas interactivos y que se llama igual, leaflet.

Vamos a usar datos de INDEC de NBI a nivel departamento que obtenemos de su geoservicio.

```{r}
library(leaflet)
nbi_deptos <- read_sf("https://github.com/martoalalu/clase-geo-salud/raw/990c36ecec182d3f8ff4dffc921c233160cb8d43/data/nbi_deptos.geojson")
```

Genial, ahora que tenemos los datos vamos a hacer un choropleth con porcentaje de personas con nbi por departamento.

Al igual que con ggplot() a R le tenemos que avisar que vamos a hacer un mapa interactivo, por eso invocamos a "leaflet" luego necesitamos 3 componentes fundamentales:

 1. Setear dónde queremos que esté centrado el mapa y en qué nivel de zoom con **setView**
 2. Agregar la capa base con **addTiles**
 3. Agregar la geometría! Si es polígono con **addPolygons**, si son puntos es **addMarkers**.

Veamos paso a paso. Primero un mapa con centro en Argentina y zoom = 4.

```{r}
leaflet() %>% 
  setView(lng = -58.446216, lat = -34.615766, zoom = 4) %>% 
  addTiles() 
```

Genial. Ahora le vamos a agregar los polígonos.

```{r}
leaflet() %>% 
  setView(lng = -58.446216, lat = -34.615766, zoom = 4) %>% 
  addTiles() %>% 
  addPolygons(data=nbi_deptos)
```

Bien, y ahora el siguiente paso es hacer el choropleth.

```{r}
detach("package:tmaptools", unload=TRUE)
library(viridisLite)

binpal <- colorBin("viridis", nbi_deptos$personas_con_nbi_porc, 8, pretty = FALSE)

leaflet() %>% 
  setView(lng = -58.446216, lat = -34.615766, zoom = 4) %>% 
  addTiles() %>% 
  addPolygons(data=nbi_deptos, stroke=FALSE, smoothFactor = 0.2, fillOpacity = .8,
    color = ~binpal(personas_con_nbi_porc))
```

Excelente! Por último vamos a agregarle un popup y una leyenda.

```{r}

leaflet() %>% 
  setView(lng = -58.446216, lat = -34.615766, zoom = 4) %>% 
  addTiles() %>% 
  addPolygons(data=nbi_deptos, stroke=FALSE, smoothFactor = 0.2, fillOpacity = .8,
    color = ~binpal(personas_con_nbi_porc),popup=paste(nbi_deptos$departamento,"<br>",nbi_deptos$provincia,"<br>","% NBI:",nbi_deptos$personas_con_nbi_porc)) %>% 
  addLegend(pal = binpal, values = nbi_deptos$personas_con_nbi_porc, opacity = 0.7, title = "% Población con NBI",
  position = "bottomright") %>% 
  addProviderTiles(providers$CartoDB.Positron) #Cambiamos la capa base

```

¿Y si queremos hacer lo mismo pero con puntos?
Fácil, reemplazamos el tipo de geometría addPolygons por addMarkers.

```{r}
leaflet() %>% 
  setView(lng = -64.1871, lat = -32.06813, zoom = 8) %>% 
  addTiles() %>% 
  addMarkers(data=Centros_Salud_Direccion)
```

# Ruteo

Como ya vimos en la clase pasada una de las operaciones espaciales más usadas es el cálculo de distancias. Ahora bien si lo que queremos medir es la distancia entre un lugar y otro poco sentido tiene hacerlo calculando una línea recta ya que no podemos llegar si no es a través de calles, avenidas, rutas, etc. Es decir que tenemos que tener en cuenta el trazado de calles y sus reglas (por donde se puede circular y por dónde no), y eso lo podemos hacer usando los servicios de ruteo.

En este caso vamos a usar el servicio de ruteo que ofrece Open Street Map, básicamente nos permite indicar un punto de partida y otro de llegada y obtener el recorrido "real", la distancia y el tiempo de duración.

Este servicio a diferencia del que ofrece GoogleMaps es libre y no requiere registrarse ni agregar ninguna tarjeta de crédito.

La librería es **osrm** y la función es **osrmRoute**, en la que le tenemos que indicar obviamene el origen y  destino con coordenadas.

Supongamos que queremos calcular cómo ir desde la Ciudad de Córdoba hasta Mina Clavero, veamos cómo funciona.

```{r}
library(osrm)

cordoba <- c(nombre = "Córdoba Capital",
                 lon = -64.197046,
                 lat = -31.412731)


mina_clavero <- c(nombre = "Mina Clavero",
             lon = -65.005235,
             lat = -31.7265)


cordoba_mina_clavero <- osrmRoute(src = cordoba, 
                                 dst = mina_clavero, 
                                 returnclass = TRUE, 
                                 overview = "full")

```

¿Qué nos respondió?

```{r}
class(cordoba_mina_clavero)
cordoba_mina_clavero
```

Excelente! Entre Córdona y Mina Clavero hay 142km y se tarda aproxiamante 119 minutos (casi 2 horas).
Y la respuesta es un **sf**, o sea que tranquilamente lo podemos pasar a un mapa!

Hagamoslo interactivo directamente!

```{r}
leaflet(cordoba_mina_clavero) %>% 
    addTiles() %>% 
    addPolylines(color = "red")
```

Si preferimos estático podemos usar ggmap asi tenemos la capa base de Córdoba.
```{r}
ggmap(cbaTerra) +
  geom_sf(data = cordoba_mina_clavero, inherit.aes=FALSE, color = 'red')
```

Por último a veces tenemos un df con origen y destino y queremos calcular la distancia.
Creemos un df con origen en 3 plazas de Buenos Aires y destino en el Hospital de Clínicas.

```{r}

#Creamos un data
x_origen <- c(-58.40352778480617,-58.38150439538028,-58.448860895241666)
y_origen <- c(-34.61722159276842,-34.62581107542229,-34.591388382930475)
nombre_origen <- c('Plaza Velasco Ibarra','Plaza Constitución','Parque de los Andes')
x_destino <- c(-58.39993395509689,-58.39993395509689,-58.39993395509689)
y_destino <- c(-34.598884680206055,-34.598884680206055,-34.598884680206055)
nombre_destino <- c('Hospital de Clínicas','Hospital de Clínicas','Hospital de Clínicas')

#Lo convertimos a dataframe
data <- data.frame(nombre_origen, x_origen, y_origen,nombre_destino,x_destino,y_destino)

bbox <- getbb("Ciudad Autónoma de Buenos Aires, Argentina")
caba <- get_stamenmap(bbox = bbox, #En bboxle indicamos los límites específicos, ya lo sabemos!
                      maptype = "terrain", #En maptype le indicamos el tipo de mapa que queremos descargarnos. 
                      zoom=13)

#Y lo mapeamos
ggmap(caba) +
  geom_point(data = data,aes(x=x_origen, y=y_origen)) +
  geom_point(data = data,aes(x=x_destino, y=y_destino), color = 'blue')

```

Podemos iterar por cada objeto y calcular la distancia, duración y geometria y luego agregarla a nuestro df.

```{r}

#Iteramos por cada elemento de nuestro dataframe y le pasamos la función de osmrRoute
for (i in 1:nrow(data))
{
origen <-  c(nombre = data$nombre_origen[i],
                 lon = data$x_origen[i],
                 lat = data$y_origen[i])

destino <-  c(nombre = data$nombre_destino[i],
             lon = data$x_destino[i],
             lat = data$y_destino[i])


recorrido <-  osrmRoute(src = origen, 
                                 dst = destino, 
                                 returnclass = TRUE, 
                                 overview = "full")

#Agregamos valores como columnas en el dataframe
data$geometria[i] <- recorrido$geometry
data$duracion[i] <- recorrido$duration
data$distance[i] <- recorrido$distance

}

#Le indicamos qué columna tiene la geometría con el trazado
data <- st_as_sf(data, sf_column_name = "geometria")


```

Y ahora sí, al mapa.

```{r}
ggmap(caba)+
  geom_sf(data=data, aes(color=nombre_origen), size=2,inherit.aes=FALSE) + 
  geom_point(data = data,aes(x=x_origen, y=y_origen)) +
  geom_point(data = data,aes(x=x_destino, y=y_destino), color = 'blue')
```

Podemos hacer que el color sea por la distancia, o por el tiempo.

```{r}
ggmap(caba)+
  geom_sf(data=data, aes(color=distance), size=2,inherit.aes=FALSE) + 
  geom_point(data = data,aes(x=x_origen, y=y_origen)) +
  geom_point(data = data,aes(x=x_destino, y=y_destino), color = 'blue')
```


# Yapa: Geolocalizando direcciones en el AMBA

Hay otros servicios que nos permiten geolocalizar direcciones!

USIG es la Unidad de Sistemas de Información Geográfica del Gobierno de la Ciudad de Buenos Aires y brinda un servicio de geocodificación (entre otras cosas) de datos de la Ciudad de Buenos Aires de manera gratuita!!!

La librería que nos facilita el uso de este servicio se llama RUMBA, la cual la instalamos con el clásico install.packages("RUMBA").

RUMBA es un conjunto de herramientas para el análisis de la Región Urbana Metropolitana de Buenos Aires usando R. Incluye funciones que permiten obtener coordenadas precisas (longitud y latitud) que corresponden a direcciones dentro de los límites de la Región Urbana Metropolitana de Buenos Aires o bien de barrios vulnerables de la Ciudad de Buenos Aires.

Las funciones consultan la API del Normalizador de direcciones y de Déficit Habitacional de la USIG. Ademas de las coordenadas, se obtiene la dirección normalizada (escrita de forma inequívoca).

Les proponemos hacer un ejercicio con las postas de vacunación de CABA

```{r, eval = FALSE}
Postas_Vacunacion <-  readxl::read_xlsx("clase-geo-salud/data/postas_vacunacion_covid.xlsx")


#vamos a explorar el objeto
head(Postas_Vacunacion)
summary(Postas_Vacunacion)

nrow(Postas_Vacunacion)
```

El dataframe tiene una columna que hace referencia a la dirección de los centros de vacunación. Pero no tenemos ni latitud ni longitud. Ya sabemos que podemos geocodificar los datos! Vamos a probar el servicio de la USIG.

Con la función *mutate_USIG_geocode* podemos agregar las columnas de lon y lat y así tener las coordenadas. La dirección debe estar expresada como “calle altura, partido”, “calle altura, municipio”, “calle y calle, partido”, o “calle altura, municipio”. El partido o municipio son opcionales. De no ser aclarados, y encontrarse múltiples direcciones que coincidan con la búsqueda, se entregaran las coordenadas dentro de la Ciudad Autónoma de Buenos Aires (si existieran), o en su defecto las del primer partido -por orden alfabético- donde se haya encontrado la dirección.

En resumen: es mejor incluir partido o municipio en las direcciones a georeferenciar.

```{r, message=FALSE, eval = FALSE}
Postas_Vacunacion_Direccion <- mutate_USIG_geocode(Postas_Vacunacion, "direccion") #paciencia. Puede tardar un poco! Utilizar la función es tan simple como indicar el DF y el nombre del campo que tiene la dirección que vamos a trabajar.

USIG_geocode(c("9 de Julio y Belgrano, Temperley", "Callao y Corrientes", "Anchorena 1210, La Lucila"))

#vamos a explorar el objeto
head(Postas_Vacunacion_Direccion)
summary(Postas_Vacunacion_Direccion)

#Solo nos queda transformarlo a objeto geográfico
Postas_Vacunacion_Direccion <- Postas_Vacunacion_Direccion %>% 
  filter(!is.na(lon), !is.na(lat)) %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326)


summary (Postas_Vacunacion_Direccion)
class(Postas_Vacunacion_Direccion)
```
