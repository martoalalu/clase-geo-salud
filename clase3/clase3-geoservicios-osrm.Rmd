---
title: "Clase 3: Geoservicios y Open StreetMap"
subtitle: "Analisis espacial con R"
author: "Martín Alalú"
output: 
  html_document:
    fig_height: 8
    fig_width: 12
    #code_folding: "hide"
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE, warning=FALSE)
```

## Geoservicios

Uno de los modos más útiles para acceder y descargar información geográfica es a través de WFS (Web Feature Service), un servicio estándar que ofrece una interfaz de comunicación que permite interactuar con los objetos geográficos. La mayoría de los institutos geográficos del mundo o entidades que producen información geográfica disponibilizan sus datos a través de este tipo de servicios ya que es un estándar en la industria.

A través de estos Geoservicios se puede ver todo el catálogo de datos disponible de un modo muy rápido y fácil y descargarse el deseado directamente desde R (o cualquier lenguaje de programación).

El [Instituto Geográfico Nacional](https://www.ign.gob.ar/NuestrasActividades/InformacionGeoespacial/ServiciosOGC) e [INDEC](https://geoservicios.indec.gov.ar/nomenclador-vias-de-circulacion/?contenido=descargas) tienen sus geoservicios (con cobertura en todo el país). IDERA (Infraestructura de Datos Espaciales de la República Argentina) publica [una lista](https://www.idera.gob.ar/index.php?option=com_content&view=article&id=335:geoservicios&catid=33&Itemid=169) con todos los geoservicios disponibles de las entidades públicas (ministerios nacionales, provincias y municipios).

La librería **sf** nos va a ayudar a consultar los WFS de un modo muy fácil a través de la función st_layers en la que tenemos que pasar como parámetro el tipo de geoservicio (WFS en este caso) seguida por la URL donde se encuentra disponible.

Veamos qué capas tiene disponible el INDEC

```{r echo=TRUE, message=FALSE}
library(sf)
library(tidyverse)

indec <- st_layers("WFS:https://geoservicios.indec.gob.ar/geoserver/wfs?getcapabilities")
indec$name
```

Tenemos 56 capas disponibles!
Si queremos descargarnos una de las capas necesitamos usar la ya conocida función **st_read** y en el parámetro le tenemos que pasar la url donde se encuentra la capa deseada.

Esta URL se compone de 2 partes:
* url_base: es la URL principal donde se encuentra el geoservicio, incluidos ya los parámetros para indicar que queremos descargarnos una capa.
* capa_wfs: nombre de la capa que queremos descargar tal como está en el listado.

Entonces si por ejemplo queremos descargar la capa "geocenso2010:nbi_radio" que tal como su nombre lo indica tiene el NBI a nivel radio censal según el Censo 2010...

```{r}
baseurl <- "https://geoservicios.indec.gob.ar/geoserver/wfs?request=GetFeature&service=WFS&typeName="
capa_wfs <- "geocenso2010:nbi_radio"

nbi_radios <- st_read(paste0(baseurl,capa_wfs))

```
Excelente! Nos descargó la capa, tiene 52.379 registros!
Veamos qué class es y algunos registros.

```{r}
class(nbi_radios)
head(nbi_radios)
```
Genial. Antes de ir al mapa nos damos cuenta que no tenemos ninguna columna que nos permita saber de qué provincia o localidad es cada registro, sólo tenemos la columna "link" que es el identificador único del radio censal.

El valor de "link" a nivel radio es una concatenación de:
codigo_provincia + codigo_departamento + codigo_fraccion_censal + codigo_radio_censal

O sea que para joinear el nombre de la provincia y la localidad vamos a necesitar descargarnos 3 archivos más disponibles en el geoservicio: 

* geocenso2010:radios_codigo: Contiene el id del radio (link) y los id de provincia y localidad.
* sig:v_departamentos: Para cada id de departamento tenemos un nombre.
* sig:v_provincias: Id y nombre de las 24 provincias

```{r}
wfs_radios_codigo <- "geocenso2010:radios_codigo"
wfs_deptos <- "sig:v_departamentos"
wfs_prov <- "sig:v_provincias"

radios_codigo <- st_read(paste0(baseurl,wfs_radios_codigo ))
deptos <- st_read(paste0(baseurl,wfs_deptos))
prov <- st_read(paste0(baseurl,wfs_prov))

```
Veamos qué tenemos.

```{r}
head(radios_codigo)
```
radios_codigo tiene la columna link y luego un id de provincia y otro de departamento. Estas columnas las podemos agregar a nuestro de df de nbi ya que también tiene la columna link.

Hagamos un left_join!

```{r}
# nbi_radios <- left_join(nbi_radios, radios_codigo, by = "link")
```
¿Qué pasó? No nos deja hacer un left_join ya que estamos usando objetos espaciales (sf) entonces nos obliga a hacer un spatial_join (st_join). 

Pero nosotros no queremos unir estos sf a través de su relación geográfica sino por tener una columna en común! 
Entonces lo que tenemos que hacer es pasar los sf a dataframe (que dejen de ser geográficos), hacer el left_join (entre dos dataframes) y luego reestablecer su geometría, que vuelvan a ser df.

```{r}
#Pasamos los objetos de sf a dataframe
nbi_radios <- as.data.frame(nbi_radios)
radios_codigo <- as.data.frame(radios_codigo)

#Chequeamos qué clase de objeto es
class(nbi_radios)
class(radios_codigo)

#Left join
nbi_radios <- left_join(nbi_radios, radios_codigo, by = "link")

```

Como tenemos que seguir joineando todavía para tener el nombre del departamento y provincia de cada radio censal antes de reestablecer la geometría a nbi_radios vamos a seguir avanzando y ver qué tiene el dataframe deptos.

```{r}
head(deptos)
```


Deptos tiene una columna con el nombre del departamento y otra que también se llama link.
Pero aca vemos que link es un número mas corto, eso es así porque en este caso el link está solo compuesto por: codigo_provincia + codigo_departamento.

Entonces para poder hacer un left_join con nbi_radios necesitamos crear una columna nueva que tenga esa misma combinación.
Vamos a llamar a esta nueva columna como prov_depto.

```{r}
nbi_radios$prov_depto <- paste0(nbi_radios$codpcia, nbi_radios$coddpto)
```

Ahora sí, pasamos deptos a dataframe y luego joineamos.

```{r}
deptos <- as.data.frame(deptos)

class(deptos)

#Left join
nbi_radios <- left_join(nbi_radios, deptos, by = c("prov_depto"="link"))
```

Excelente!
Ahora solo nos queda joinear para tener el nombre de la provincia.
```{r}
head(prov)
```
Como era esperable aca el link es el id de la provincia. Vamos al join entonces.

```{r}
prov <- as.data.frame(prov)

class(prov)

#Left join
nbi_radios <- left_join(nbi_radios, prov, by = c("codpcia"="link"))

colnames(nbi_radios)
```

Listo!
Vamos a seleccionar solo las columnas que nos interesan asi queda más limpio el dataframe.

```{r}
nbi_radios <- nbi_radios %>% 
              select(link, #id del radio censal
                     nombre.x, #nombre del departamento
                     nombre.y, #nombre de la provincia
                     personas_con_nbi,
                     personas_con_nbi_porc,
                     total_pob,
                     hogares_con_nbi,
                     hogares_con_nbi_porc,
                     total_hog,
                     geom.x #geometria
              ) %>% 
              rename(departamento = nombre.x,
                     provincia = nombre.y)
```

Y ahora sí reestablecemos la geometría con la función **st_sf**.

```{r}
nbi_radios  <-  st_sf(nbi_radios, sf_column_name = 'geom.x')
class(nbi_radios)
```

Por último al mapa!
Veamos como se distribuye el porcentaje de hogares con nbi en la provincia de Córdoba.

```{r}
cordoba_nbi <- filter(nbi_radios, provincia == "Córdoba")

ggplot() + 
  geom_sf(data = cordoba_nbi, aes(fill = hogares_con_nbi_porc), color = NA) +
  scale_fill_viridis_c() +
  theme_void() +
  labs(title = "Porcentaje de hogares con NBI a nivel radio censal",
       subtitle = "Córdoba - 2010",
       fill = "% hogares con NBI",
       caption = "Elaboración propia en base a datos de INDEC")
```

## Open Street Map: la wiki de mapas

OpenStreetMap es una de las comunidades geoespaciales más importantes a través de la cual todos podemos aportar información espacial del lugar que querramos, es algo asi como la versión de mapas de Wikipedia. Al ser una iniciativa basada en la colaboración tiene una fuerte política de apertura de datos, por lo que todos sus datos se pueden consultar y descargar libremente!

Probemos descargarnos las plazas de Villa Allende, Córdoba.
La librería que nos va a facilitar el acceso a los datos es **osmdata**.
Lo primero que tenemos que hacer es construir nuestro bounding box, es decir especificar de qué coordenadas queremos los datos. Para eso usamos la función **getbb**, en la que le tenemos que pasar el nombre exacto del lugar que buscamos.


```{r}
library(osmdata)

bbox <- getbb("Villa Allende, Córdoba")
bbox
```

Pefecto. Tenemos los límites. La función **getbb** también permite extraer el polígono de un área en formato sf, para eso sólo le tenemos que indicar el formato de salida.

```{r}
allende_poly <- getbb("Municipio de Villa Allende, Córdoba", format_out = "sf_polygon")
class(allende_poly)
```

Ahora lo siguiente es construir la consulta a la base de datos de Open Street Map en la que le indicamos que queremos descargarnos las plazas de Villa Allende.
La función es opq, que tiene como parámetro el bounding box y luego le tenemos que agregar los objetos que queremos extraer, lo cual hacemos con add_osm_feature indicando la key que queremos consultar.

Para ver cómo están catálogados cada uno de los objetos de OSM pueden ver su [Wiki](https://wiki.openstreetmap.org/wiki/ES:).

```{r}
allende <- opq(bbox) %>% 
    add_osm_feature(key = "leisure", value = "park")

allende
```

Y ahora hacemos la consulta a la base de datos propiamente dicha con **osmdata_sf**.

```{r}
allende <- allende %>% 
    osmdata_sf()

allende
```

Y nos quedamos con los polígonos de la respuesta a la consulta que hicimos.


```{r}
allende_plazas <- allende$osm_polygons

head(allende_plazas) 
```

Listo! Ahora podemos hacer un mapa.
```{r}
ggplot() +
    geom_sf(data=allende_poly, fill = NA) +
    geom_sf(data = allende_plazas, fill = "green", color = NA) 
```

Quedaron plazas afuera de los límites de Villa Allende! Eso ocurre porque la consulta de las plazas la hicimos con todo el recuardo (bounding box) y no sólo con los límites exatos.
Pero fácilmente las podemos filtrar usando **st_intersection**!

```{r}
allende_plazas_limite <- st_intersection(allende_plazas, allende_poly)

ggplot() +
    geom_sf(data=allende_poly, fill = NA) +
    geom_sf(data = allende_plazas_limite, fill = "green", color = NA)
```


