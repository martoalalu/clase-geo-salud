---
title: "Clase 2: Operaciones Espaciales"
subtitle: "Analisis espacial con R"
author: "Martín Alalú"
date: "29/04/2020"
output: 
  html_document:
    fig_height: 8
    fig_width: 12
    #code_folding: "hide"
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE, warning=FALSE)
```

# Operaciones espaciales

Hay una enorma cantidad de operaciones que se le pueden hacer a los objetos geográficos. Calcular el área, el perímetro, el largo, distancias entre objetos, intersecciones, uniones, diferencias, realizar transformaciones y más!
Estas manipulaciones son sumamente útiles ya que nos permitirán comprender mejor el fenómeno que estamos analizando.

Para más información de todas las operaciones posibles (o las principales) sugerimos revisar el [capítulo 4 del libro Geocomputation with R](https://geocompr.robinlovelace.net/spatial-operations.html).


# Área, perímetro e intersección

Como siempre comenzamos cargando las librerías que vamos a usar. Recuerden que si no las tienen instaladas aún lo pueden hacer con *install.packages("NOMBRE_LIBRERIA")*.

De paso cargamos un dataframe geográfico (formato .shp) que tiene los polígonos de las provincias de Argentina.

```{r Cargamos librerias, echo=TRUE, message=FALSE}
library(sf) 
library(tidyverse)
library(units) 

prov <- read_sf("clase-geo-salud/data/ar_provincias.geojson")
```

Veamos qué información tiene.
```{r echo=TRUE, message=FALSE}
head(prov)
```

Ok, sólo el nombre y el campo de geometría, obvio.
Hagamos un mapa!

```{r}
ggplot(prov) +
    geom_sf()
```

Podemos rellenar cada provincia con un color distinto.

```{r}
ggplot(prov) +
    geom_sf(aes(fill=provincia))
```

Ok. Ahora sí, empecemos a agregarle información a este dataframe.
Calcular el área es muy simple con la función **st_area** de la librería **sf**.

```{r}
st_area(prov) #nos devuelve en unidades raras, pasamos a km2
```

Mmm suenan raros estos números. Pasemos la unidad de medición a kilómetros cuadrados!

```{r}
set_units(st_area(prov), km^2)
```

Ahí va mejor. Pero seguimos sin saber a qué provincia corresponde cada registro. Lo pasamos a formato numérico y agregamos como columna nueva!


```{r}
prov$area <- as.numeric(set_units(st_area(prov), km^2))
prov
```

Bien! Ahora que tenemos una columna con el área podemos hacer un mapa coloreando cada provincia según los km2.

```{r}
ggplot(prov) +
  geom_sf(aes(fill=area))
```

Mmm está mal, pero no tan mal. Lo que ya sabíamos, la Provincia de Buenos Aires es la más grande del país, pero también se ve cierto patrón, a medida que pasamos de Norte a Sur el gradiente se ve más claro, o sea que las provincias suelen ser más grandes...

Hagamos un gráfico de barras para ver este patrón.

```{r}
ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, area), weight=area, fill=area)) +
  coord_flip() 
```

Claro, al pasar del mapa al gráfico de barras perdemos la referencia geográfica. Agreguemos una columna con la región de la provincia para ver si las de la Patagonia suelen ser más grandes que las del Norte.

```{r}
prov <- prov %>% 
  mutate(region =
  case_when(
        provincia %in% (c("Buenos Aires", "Córdoba", "La Pampa", "Entre Ríos", "Santa Fe", "Ciudad de Buenos Aires")) ~ "Pampeana",
        provincia %in% (c("Mendoza", "San Luis", "San Juan")) ~ "Cuyo",
        provincia %in% (c("La Rioja", "Catamarca", "Jujuy", "Salta", "Tucumán", "Santiago del Estero")) ~ "Noroeste",
        provincia %in% (c("Corrientes", "Misiones", "Formosa", "Chaco")) ~ "Noreste",
        TRUE ~ "Patagonia"
        )
  )

ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, area), weight=area, fill=region)) +
  coord_flip() 

```

Ahí va mejor! Hay cierto patrón, 3 de las 4 provincias más grande son de la Patagonia y 5 de las 6 más chicas del Norte!
Esto nos sirve para entender que al hacer análisis espacial a veces salir del mapa puede ser sumamente útil para ver patrones.

Una más y listo. Agreguemos una línea vertical con la media del área de las provincias para ver cuáles están por encima y cuáles por debajo.

```{r}
ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, area), weight=area, fill=region)) +
 geom_hline(yintercept=mean(prov$area), linetype="dashed", 
                color = "black", size=0.5) +
  coord_flip() 
```

¿Qué conclusiones sacan ahora?

Bueno, sigamos con el perímetro. La función es **st_length**.

```{r}
st_length(prov)
```

Vemos que la unidad de medida son metros, lo pasamos a km con solo dividirlo por 1000 y agregamos a columna nueva.

```{r}
prov$perimetro <- as.numeric(st_length(prov) / 1000)
prov
```

Excelente! Ahora sí, al mapa.

```{r}
ggplot(prov) +
  geom_sf(aes(fill=perimetro))
```

Y al gráfico de barras.

```{r}
ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, perimetro), weight=perimetro, fill=region)) +
 geom_hline(yintercept=mean(prov$perimetro), linetype="dashed", 
                color = "black", size=0.5) +
  coord_flip() 
```


# Intersecciones

Otra de las operaciones espaciales más útiles es la de calcular intersecciones entre 2 objetos espaciales. Por ejemplo ver qué puntos (escuelas) caen dentro de un polígono (ej. barrio).
Muchas veces la información disponible es de un universo mucho mayor a nuestro fenómeno de estudio y necesitamos hacer un recorte, ahí es dónde **st_intersects** nos puede ayudar.

Asimismo por ahora estuvimos manejando un tipo de dato geográfico (polígonos) y haciendo un estilo de mapas (coropléticos), probemos usando datos que sean puntos y hagamos otros tipos de mapas.

Vamos a usar un dataset disponibilizado por el Ministerio de Salud del Gobierno Nacional que contiene la ubicación exacta todos los efectores de salud del país.

```{r}
#Cargamos los datos
salud <- read.csv("https://github.com/martoalalu/clase-geo-salud/raw/master/data/refes-hospitales.csv", fileEncoding = 'UTF-8')

#Vemos la clase de objeto que es
class(salud)

head(salud)
summary(salud)
```

Lo cargamos como un dataframe normal *no-geográfico* pero al explorarlo vemos que tiene 2 columnas que sí precisan su ubicación exacta en la tierra, *LATITUD* y *LONGITUD*. Tenemos que hacerle entender a R que se trata de un dataframe geográfico, es fácil!

Primero filtramos y sólo nos quedamos con las observaciones que no son nulas ya que no podemos ubicar en un mapa objetos con latitud y longitud nulas.
Luego con `st_as_sf` convertimos el dataframe a un objeto geográfico indicandole dónde están los datos de las coordenadas y le indicamos el sistema de referencia de coordenadas.

```{r}
salud <- salud %>% 
  filter(!is.na(LONGITUD), !is.na(LATITUD)) %>% 
  st_as_sf(coords = c("LONGITUD", "LATITUD"), crs = 4326)

class(salud)
head(salud)
```

Como ven el objeto `salud` pasó de ser un *dataframe* a un *sf dataframe*, o sea un *dataframe geográfico*.
Y también podemos ver todas las características del objeto. El tipo de geometría es **punto**, tiene 2 dimensiones y el **CRS es 4326** el mismo que el de radios.

Ahora podemos mapear. Y lo hacemos igual que con el dataset de barrios y radios.

```{r}
ggplot()+
  geom_sf(data=salud)
```

No tenemos los límites de Argentina pero claramente los puntos de los efectores parecen distribuirse en todo el país.
Pero nosotros queremos trabajar solo con datos de la Ciudad de Buenos Aires!
Una opción es filtrar a través de un atributo "no-geográfico" como por ejemplo el nombre de la Provincia, pero en este caso no tenemos esa información!

A no desesperarse! Una de las bondades de los datos geográficos es que podemos hacer consultas espaciales. En este caso vamos a pedirle a R que **espacialmente nos filtre y seleccione** todos los efectores de salud que caen dentro de algún barrio de Buenos Aires. Para eso usamos `st_intersection` una de las funciones espaciales de la librería **sf**.

Cargamos un nuevo dataframe con el polígono de la Ciudad de Buenos Aires.

```{r}
caba <- filter(prov, provincia == "Ciudad de Buenos Aires")

ggplot(caba) +
  geom_sf()
```


le indicamos nuestro objeto geográfico a filtrar y luego el dataframe con el que filtrar, en este caso el df de barrios de la Ciudad.

```{r}
#Nos quedamos solo con los efectores de salud que están dentro de barrios
salud_caba <- st_intersection(salud, barrios)
```

La consulta espacial dio como resultado un nuevo dataframe que nos indica que en la Ciudad de Buenos Aires hay 1154 efectores de salud.

Ahora sí, volvamos al mapa. Al igual que en cualquier gráfico de `ggplot()` podemos combinar capas. Vamos a agregar una capa con los barrios detrás para tener la referencia.

```{r}
ggplot()+
  geom_sf(data=barrios)+
  geom_sf(data=salud_caba)
```

A priori la distribución es parecida a la de densidad poblacional!

**Ejercicio**. Supongamos que querramos hacer un mapa que muestre la capacidad de respuesta del sistema de salud porteño, o sea sólo aquellos efectores que tengan internación. ¿Cómo lo hacemos?
Va tip, el campo `TIPOLOGÍA` nos va a ayudar.


Volvamos al mapa, pero profundizando el análisis. Vamos a pintar cada efector según la columna `ORIGEN_FINANCIAMIENTO` el cual indica si es *público* o *privado* para ver cómo es la distribución espacial.

```{r}
ggplot()+
  geom_sf(data=barrios)+
  geom_sf(data=salud_caba, aes(color=ORIGEN_FINANCIAMIENTO))
```

Para emprolijar podemos hacer *facetar* el mapa, al igual que con cualquier visualización de ggplot().

```{r}
ggplot()+
  geom_sf(data=barrios)+
  geom_sf(data=salud_caba, aes(color=ORIGEN_FINANCIAMIENTO))+
  facet_wrap(~ORIGEN_FINANCIAMIENTO)
```

Vamos con otro ejercicio ¿Cómo sería si quisieramos hacer un nuevo mapa choropleth con la cantidad de efectores de salud con internación por barrio?


# Más allá del choropleth

Hagamos otros tipos de mapas. Tener ubicaciones exactas, es decir objetos que son puntos, nos permiten hacer otros tipos de mapas como de *calor (heatmap)*, de *burbujas (bubblemap)* o de *densidad (densitymap)*, entre otros.

Dejemos de usar un rato la librería **sf** y vamos a considerar nuestro dataframe de efectores de salud en Buenos Aires como cualquier otro *no geográfico*. 

Antes con `st_as_coord()` habíamos transformado las columnas de *latitud* y *longitud* en una **geometry** ahora vamos a reestablecer esas columnas.


```{r}
#Reestablecemos las columnas lat y long con sus coordenadas
salud_caba$long <- st_coordinates(salud_caba)[,1]
salud_caba$lat <- st_coordinates(salud_caba)[,2]

#Le decimos a R que salud_caba_intern deja de ser un objeto geográfico
st_geometry(salud_caba) <- NULL

class(salud_caba)
```

Ahora *salud_caba* es un dataframe normal que tiene una columna *latitud* y otra *longitud* que expresan la posición de los elementos en la superficie terrestre. O sea que si hacemos un

Volvamos a **ggplot()** y hagamos un geom_point() tradicional.

```{r}
ggplot() +
  geom_point(data = salud_caba, aes(x = long, y = lat,color = ORIGEN_FINANCIAMIENTO))
```

Ven que queda igual que si fuera un objeto geográfico!
Aprovechemos nuevas funciones de ggplot() para hacer nuevos gráficos que "simulen" ser un mapa.
Un mapa de densidad de puntos que muestre las zonas con mayor concentración de efectores.

```{r}
ggplot() +
    geom_bin2d(data = salud_caba, aes(x = long, y = lat), bins = 50) +
    scale_fill_viridis_c()+
    labs(title = "Concentración de efectores de salud",
         fill = "Cantidad")
```

A todo esto siempre estuvimos trabajando con puntos y polígonos asumiendo que el fondo es Buenos Aires. Pero podemos agregar una capa base que tenga el mapa de Buenos Aires.

Para eso vamos a usar las librerías `ggmap` y `osmdata`, las cuales instalamos con el tradicional `install.packages("NOMBRE_LIBRERIA")` y agregamos con `library(NOMBRE_LIBRERIA)`. 
Con estas nuevas librería podemos agregar capas de fondo muy fácilmente.

Básicamente lo primero que tenemos que hacer es indicarle a R cuál es el limite, el *boundin gbox* del mapa que queremos descargarnos. Usamos la función `getbb` y le decimos que es "Ciudad Autónoma de Buenos Aires" ya que es el nombre oficial. Si estuvieramos haciendo un mapa de por ejemplo Rosario le indicaríamos "Rosario, Santa Fe, Argentina".

Luego, con `get_stamenmap` le indicamos especialmente que nos descargue el mapa, en este caso el tipo de mapa que nos estamos descargando es el `toner-background`, pero si quieren otro tipo pueden chequear la página de [Stamen Maps](http://maps.stamen.com/#terrain/12/37.7706/-122.3782).

Luego, en vez de usar ggplot() vamos a usar `ggmap()` pero no se preocupen la sintaxis sigue siendo la misma!

```{r}
library(ggmap)
library(osmdata)

#Indicamos cual es la ciudad de fondo que queremos
bbox <- getbb("Ciudad Autónoma de Buenos Aires,Argentina")

#Descargamos el mapa
CABA <- get_stamenmap(bbox = bbox,
                      maptype = "terrain",zoom=12)

# Mapa solo
ggmap(CABA)
```

Nos faltan los datos pero ahora sabemos con certeza que el fondo corresponde a Buenos Aires.

Si no nos gusta este mapa podemos probar con otro, por ejemplo con `toner-background`.

```{r}
#Descargamos el mapa
CABA <- get_stamenmap(bbox = bbox,
                      maptype = "toner-background",zoom=12)

ggmap(CABA)
```

Ahora si, agregemos los datos!

```{r}
ggmap(CABA)+
  geom_bin2d(data = salud_caba, aes(x = long, y = lat), bins = 50) +
    scale_fill_viridis_c()
```

Excelente!
Ahora probemos con un mapa que muestre la misma información pero simulando curvas de nivel.

```{r}

ggmap(CABA) +
  stat_density2d(data = salud_caba, aes(x = long, y = lat, fill=stat(level)),geom="polygon")+
  scale_fill_viridis_c()

```

Facetemos!

```{r}
ggmap(CABA) +
  stat_density2d(data = salud_caba, aes(x = long, y = lat, fill=stat(level)),geom="polygon")+
  scale_fill_viridis_c()+
  facet_wrap(~ORIGEN_FINANCIAMIENTO)
```

Al parecer los privados se concentran claramente en el centro, y de destaca también una concentración alta en la parte norte de la capital, mientras que los establecimientos públicos no tienen una concentración clara.

Por último hagamos un mapa de burbujas, donde el tamaño de cada punto que representa al efector está dado por la cantidad de casos de covid que tuvo el barrio en el que está.

```{r}
ggmap(CABA) +
  geom_point(data = filter(salud_caba,ORIGEN_FINANCIAMIENTO=="Público"), aes(x = long, y = lat, size=total), color="red")
  
```


