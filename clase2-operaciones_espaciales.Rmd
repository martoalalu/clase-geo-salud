---
title: "Clase 2: Operaciones Espaciales"
subtitle: "Analisis espacial con R"
author: "Martín Alalú"
date: "29/04/2021"
output: 
  html_document:
    fig_height: 8
    fig_width: 12
    #code_folding: "hide"
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE, warning=FALSE)
```

# Operaciones espaciales

Hay una enorma cantidad de operaciones que se le pueden hacer a los objetos geográficos. Calcular el área, el perímetro, el largo, distancias entre objetos, intersecciones, uniones, diferencias, realizar transformaciones y más!
Estas manipulaciones son sumamente útiles ya que nos permitirán comprender mejor el fenómeno que estamos analizando.

Para más información de todas las operaciones posibles (o las principales) sugerimos revisar el [capítulo 4 del libro Geocomputation with R](https://geocompr.robinlovelace.net/spatial-operations.html).


# Área, perímetro e intersección

Como siempre comenzamos cargando las librerías que vamos a usar. Recuerden que si no las tienen instaladas aún lo pueden hacer con *install.packages("NOMBRE_LIBRERIA")*.

De paso cargamos un dataframe geográfico (formato .shp) que tiene los polígonos de las provincias de Argentina.

```{r Cargamos librerias, echo=TRUE, message=FALSE}
library(sf) 
library(tidyverse)
library(units) 

options(scipen = 999)

prov <- read_sf("https://raw.githubusercontent.com/martoalalu/clase-geo-salud/clase-2021/data/ar_provincias.geojson")
```

Veamos qué información tiene.
```{r echo=TRUE, message=FALSE}
head(prov)
```

Ok, sólo el nombre y el campo de geometría, obvio.
Hagamos un mapa!

```{r}
ggplot(prov) +
    geom_sf()
```

Podemos rellenar cada provincia con un color distinto.

```{r}
ggplot(prov) +
    geom_sf(aes(fill=provincia))
```

Ok. Ahora sí, empecemos a agregarle información a este dataframe.
Calcular el área es muy simple con la función **st_area** de la librería **sf**.

```{r}
st_area(prov) #nos devuelve en unidades raras, pasamos a km2
```

Mmm suenan raros estos números. Pasemos la unidad de medición a kilómetros cuadrados!

```{r}
set_units(st_area(prov), km^2)
```

Ahí va mejor. Pero seguimos sin saber a qué provincia corresponde cada registro. Lo pasamos a formato numérico y agregamos como columna nueva!


```{r}
prov$area <- as.numeric(set_units(st_area(prov), km^2))
prov
```

Bien! Ahora que tenemos una columna con el área podemos hacer un mapa coloreando cada provincia según los km2.

```{r}
ggplot(prov) +
  geom_sf(aes(fill=area))
```

Mmm está mal, pero no tan mal. Lo que ya sabíamos, la Provincia de Buenos Aires es la más grande del país, pero también se ve cierto patrón, a medida que pasamos de Norte a Sur el gradiente se ve más claro, o sea que las provincias suelen ser más grandes...

Hagamos un gráfico de barras para ver este patrón.

```{r}
ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, area), weight=area, fill=area)) +
  coord_flip() 
```

Claro, al pasar del mapa al gráfico de barras perdemos la referencia geográfica. Agreguemos una columna con la región de la provincia para ver si las de la Patagonia suelen ser más grandes que las del Norte.

```{r}
prov <- prov %>% 
  mutate(region =
  case_when(
        provincia %in% (c("Buenos Aires", "Córdoba", "La Pampa", "Entre Ríos", "Santa Fe", "Ciudad de Buenos Aires")) ~ "Pampeana",
        provincia %in% (c("Mendoza", "San Luis", "San Juan")) ~ "Cuyo",
        provincia %in% (c("La Rioja", "Catamarca", "Jujuy", "Salta", "Tucumán", "Santiago del Estero")) ~ "Noroeste",
        provincia %in% (c("Corrientes", "Misiones", "Formosa", "Chaco")) ~ "Noreste",
        TRUE ~ "Patagonia"
        )
  )

ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, area), weight=area, fill=region)) +
  coord_flip() 

```

Ahí va mejor! Hay cierto patrón, 3 de las 4 provincias más grande son de la Patagonia y 5 de las 6 más chicas del Norte!
Esto nos sirve para entender que al hacer análisis espacial a veces salir del mapa puede ser sumamente útil para ver patrones.

Una más y listo. Agreguemos una línea vertical con la media del área de las provincias para ver cuáles están por encima y cuáles por debajo.

```{r}
ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, area), weight=area, fill=region)) +
 geom_hline(yintercept=mean(prov$area), linetype="dashed", 
                color = "black", size=0.5) +
  coord_flip() 
```

¿Qué conclusiones sacan ahora?

Bueno, sigamos con el perímetro. La función es **st_length**.

```{r}
st_length(prov)
```

Vemos que la unidad de medida son metros, lo pasamos a km con solo dividirlo por 1000 y agregamos a columna nueva.

```{r}
prov$perimetro <- as.numeric(st_length(prov) / 1000)
prov
```

Excelente! Ahora sí, al mapa.

```{r}
ggplot(prov) +
  geom_sf(aes(fill=perimetro))
```

Y al gráfico de barras.

```{r}
ggplot(prov) + 
  geom_bar(aes(x= reorder(provincia, perimetro), weight=perimetro, fill=region)) +
 geom_hline(yintercept=mean(prov$perimetro), linetype="dashed", 
                color = "black", size=0.5) +
  coord_flip() 
```


# Intersecciones

Otra de las operaciones espaciales más útiles es la de calcular intersecciones entre 2 objetos espaciales. Por ejemplo ver qué puntos (escuelas) caen dentro de un polígono (ej. barrio).
Muchas veces la información disponible es de un universo mucho mayor a nuestro fenómeno de estudio y necesitamos hacer un recorte, ahí es dónde **st_intersects** nos puede ayudar.

Asimismo por ahora estuvimos manejando un tipo de dato geográfico (polígonos) y haciendo un estilo de mapas (coropléticos), probemos usando datos que sean puntos y hagamos otros tipos de mapas.

Vamos a usar un dataset disponibilizado por el Ministerio de Salud del Gobierno Nacional que contiene la ubicación exacta todos los efectores de salud del país.

```{r}
#Cargamos los datos
salud <- read.csv("https://github.com/martoalalu/clase-geo-salud/raw/master/data/refes-hospitales.csv", fileEncoding = 'UTF-8')

#Vemos la clase de objeto que es
class(salud)

head(salud)
summary(salud)
```

Lo cargamos como un dataframe normal *no-geográfico* pero al explorarlo vemos que tiene 2 columnas que sí precisan su ubicación exacta en la tierra, *LATITUD* y *LONGITUD*. Tenemos que hacerle entender a R que se trata de un dataframe geográfico, es fácil!

Primero filtramos y sólo nos quedamos con las observaciones que no son nulas ya que no podemos ubicar en un mapa objetos con latitud y longitud nulas.
Luego con `st_as_sf` convertimos el dataframe a un objeto geográfico indicandole dónde están los datos de las coordenadas y le indicamos el sistema de referencia de coordenadas.

```{r}
salud <- salud %>% 
  filter(!is.na(LONGITUD), !is.na(LATITUD)) %>% 
  st_as_sf(coords = c("LONGITUD", "LATITUD"), crs = 4326)

class(salud)
head(salud)
```

Como ven el objeto `salud` pasó de ser un *dataframe* a un *sf dataframe*, o sea un *dataframe geográfico*.
Y también podemos ver todas las características del objeto. El tipo de geometría es **punto**, tiene 2 dimensiones y el **CRS es 4326** el mismo que el de radios.

Ahora podemos mapear. Y lo hacemos igual que con el dataset de barrios y radios.

```{r}
ggplot()+
  geom_sf(data=salud)
```

No tenemos los límites de Argentina pero claramente los puntos de los efectores parecen distribuirse en todo el país.
Pero nosotros queremos trabajar solo con datos de la Ciudad de Buenos Aires!
Una opción es filtrar a través de un atributo "no-geográfico" como por ejemplo el nombre de la Provincia, pero en este caso no tenemos esa información!

A no desesperarse! Una de las bondades de los datos geográficos es que podemos hacer consultas espaciales. En este caso vamos a pedirle a R que **espacialmente nos filtre y seleccione** todos los efectores de salud que caen dentro de algún barrio de Buenos Aires. Para eso usamos `st_intersection` una de las funciones espaciales de la librería **sf**.

Cargamos un nuevo dataframe con el polígono de la Ciudad de Buenos Aires.

```{r}
caba <- read_sf("https://raw.githubusercontent.com/martoalalu/clase-geo-salud/clase-2021/data/caba.geojson")

ggplot(caba) +
  geom_sf()
```


Queremos quedarnos solo con los efectores de salud (puntos) que caen dentro de la Ciudad de Buenos Aires (polígono).
Entonces indicamos nuestro objeto geográfico a filtrar (efectores de salud) y luego el dataframe con el que filtrar (poligono de Buenos Aires).

```{r}
#Nos quedamos solo con los efectores de salud que están dentro de barrios
salud_caba <- st_intersection(salud, caba)
```

La consulta espacial dio como resultado un nuevo dataframe que nos indica que en la Ciudad de Buenos Aires hay 1165 efectores de salud.

Ahora sí, volvamos al mapa. Al igual que en cualquier gráfico de `ggplot()` podemos combinar capas. Vamos a agregar una capa el polígono de la Ciudad de Buenos Aires detrás para tener la referencia.

```{r}
ggplot()+
  geom_sf(data=caba)+
  geom_sf(data=salud_caba)
```

A priori la distribución es parecida a la de densidad poblacional!

**Ejercicio**. Supongamos que querramos hacer un mapa que muestre la capacidad de respuesta del sistema de salud porteño, o sea sólo aquellos efectores que tengan internación. ¿Cómo lo hacemos?
Va tip, el campo `TIPOLOGÍA` nos va a ayudar.


Volvamos al mapa, pero profundizando el análisis. Vamos a pintar cada efector según la columna `ORIGEN_FINANCIAMIENTO` el cual indica si es *público* o *privado* para ver cómo es la distribución espacial.

```{r}
ggplot()+
  geom_sf(data=caba)+
  geom_sf(data=salud_caba, aes(color=ORIGEN_FINANCIAMIENTO))
```

Para emprolijar podemos hacer *facetar* el mapa, al igual que con cualquier visualización de ggplot().

```{r}
ggplot()+
  geom_sf(data=caba)+
  geom_sf(data=salud_caba, aes(color=ORIGEN_FINANCIAMIENTO))+
  facet_wrap(~ORIGEN_FINANCIAMIENTO)
```


# Más allá del choropleth

Hagamos otros tipos de mapas. Tener ubicaciones exactas, es decir objetos que son puntos, nos permiten hacer otros tipos de mapas como de *calor (heatmap)*, de *burbujas (bubblemap)* o de *densidad (densitymap)*, entre otros.

Dejemos de usar un rato la librería **sf** y vamos a considerar nuestro dataframe de efectores de salud en Buenos Aires como cualquier otro *no geográfico*. 

Antes con `st_as_coord()` habíamos transformado las columnas de *latitud* y *longitud* en una **geometry** ahora vamos a reestablecer esas columnas, o sea vamos a hacer que dejen de ser columnas geográficas y ser sólo "numéricas".

```{r}
#Reestablecemos las columnas lat y long con sus coordenadas
salud_caba$long <- st_coordinates(salud_caba)[,1]
salud_caba$lat <- st_coordinates(salud_caba)[,2]

#Le decimos a R que salud_caba_intern deja de ser un objeto geográfico
st_geometry(salud_caba) <- NULL

class(salud_caba)
```

Ahora *salud_caba* es un dataframe normal que tiene una columna *latitud* y otra *longitud* que expresan la posición de los elementos en la superficie terrestre. O sea que si hacemos un

Volvamos a **ggplot()** y hagamos un geom_point() tradicional.

```{r}
ggplot() +
  geom_sf(data=caba) +
  geom_point(data = salud_caba, aes(x = long, y = lat,color = ORIGEN_FINANCIAMIENTO))
```

Ven que queda igual que si fuera un objeto geográfico!
Aprovechemos nuevas funciones de ggplot() para hacer nuevos gráficos que "simulen" ser un mapa.
Un mapa de densidad de puntos que muestre las zonas con mayor concentración de efectores.

```{r}
ggplot() +
    geom_sf(data=caba) +
    geom_bin2d(data = salud_caba, aes(x = long, y = lat), bins = 50) +
    scale_fill_viridis_c()+
    labs(title = "Concentración de efectores de salud",
         fill = "Cantidad")
```

Si no nos gusta que sean cuadrados pueden ser hexagonos!

```{r}
ggplot() +
    geom_sf(data=caba) +
    geom_hex(data = salud_caba, aes(x = long, y = lat), bins = 50) +
    scale_fill_viridis_c()+
    labs(title = "Concentración de efectores de salud",
         fill = "Cantidad")
```

O bien, las zonas de calor pueden ser más estilo "curvas de nivel".

```{r}
ggplot() +
  geom_sf(data=caba) +
  stat_density2d(data = salud_caba, aes(x = long, y = lat, fill=stat(level)),geom="polygon")+
  scale_fill_viridis_c()
```


# Calculando distancias

Calcular distancias es una de las funciones espaciales más útiles ya que permite ver con claridad cómo la accesibilidad a distintos bienes y servicios se distribuye desigualmente en el espacio. En tiempos de coronavirus y cuarentena ésta cuestión cobró mayor relevancia ya que al limitarse la movilidad de las personas se cristalizan los patrones espaciales, haciendo que una parte de la población tenga un acceso privilegiado a bienes y servicios mientras que otra queda se ve obligada a trasladarse más para conseguir lo mismo (y por ende se expone más al virus).

Una de las cuestiones que surgió fue la limitación para moverse a no más de 500 metros a la redonda. Analicemos esta medida en términos de acceso a un espacio verde, algo que la Organización Mundial de la Salud considera vital para el bienestar de la población. ¿Qué porción de la población de la Ciudad de Buenos Aires está a 500 metros de una plaza?

Hagamos un choropleth map que muestre con mayor intensidad aquellos radios censales que están más cerca de una plaza.

Para esto usaremos 2 datasets: radios censales y ubicación de espacios verdes, del portal de datos abiertos del Gobierno de la Ciudad de Buenos Aires.


## Explorando los datos
```{r datos, echo=TRUE, message=FALSE}
#Cargamos los datos
radios <- st_read('https://github.com/martoalalu/clase-geo-salud/raw/master/data/caba_radios.geojson')
plazas <- st_read("https://github.com/martoalalu/clase-geo-salud/raw/master/data/espacios-verdes-catastrales.geojson")


ggplot() +
  geom_sf(data=plazas, fill="green")
```

Tenemos 1402 espacios verdes. Veamos qué categorías hay en el campo `TIPO_EV`.

```{r, echo=TRUE, message=FALSE}
unique(plazas$TIPO_EV)
```

Vemos que hay espacios verdes que son canteros, plazoletas o en autopistas. Nuestro objetivo es ver el acceso a espacios verdes en los que las personas puedan distenderse y realizar algún tipo de actividad, por eso vamos a quedarnos sólo con las plazas, parques, jardín botánico, bosque, reserva ecológica, parque deportivo y espacios verdes.

```{r, echo=TRUE, message=FALSE}
plazas <- filter(plazas,TIPO_EV %in% c("PLAZA","PARQUE","JARDÍN BOTÁNICO","BOSQUE","RESERVA ECOLÓGICA","ESPACIO VERDE","PARQUE DEPORTIVO", "ESPACIO PÚBLICO"))

ggplot() +
  geom_sf(data=plazas, fill="green")
```

## Del polígono al centroide

Para calcular distancias necesitamos hacerlo de un punto exacto a otro. Necesitamos transformar nuestros polígonos (plazas y radios) en puntos exactos, para eso vamos a crear 2 nuevas capas que tengan el centroide de cada plaza y radio. Con `st_point_on_surface` nos aseguramos que el punto caiga adentro del polígono.

```{r, echo=TRUE, message=FALSE}
plazas_c <- st_point_on_surface(plazas)
radios_c <- st_point_on_surface(radios)
```

Volvamos al mapa.

```{r, echo=TRUE, message=FALSE}
ggplot() +
  geom_sf(data=radios_c, size=0.5) +
  geom_sf(data=radios, fill=NA) +
  geom_sf(data=plazas, fill=NA) +
  geom_sf(data=plazas_c, color="lightgreen")
```

## De un centroide a otro

Perfecto. Ahora bien, lo que queremos hacer es para cada centroide del radio censal encontrar el centroide de la plaza más cercana, calcular su distancia y agregarla como columna al dataframe de radios.

Se hace en pocas líneas pero vamos a explicarlo paso a paso

Primero tenemos que pedirle a R que por cada centroide de radio censal busque el centroide de la plaza más cercana. Esto lo hacemos utilizando la función `st_nearest_feature`.

```{r, echo=TRUE, message=FALSE}
st_nearest_feature(radios_c,plazas_c)[1:5]

radios_c[1,]
plazas_c[283,]
```

Lo que nos devuelve es una lista en la que asocia el index de cada elemento de radios_c con el index más cercano de plazas_c. Así sabemos que el primer radio censal (index = 1, Radio_id = 1_1_1) tiene como plaza más cercana a la ubicada en el index = 283 (Plaza Canadá). 


Lo que vamos a hacer es calcular distancia elemento por elemento y para ello necesitamos tener "parejas" de radios y plazas, que por cada radio haya sí o sí una plaza asociada. 
Esto es sumamente útil ya que R va a agarrar el primer elemento de radios_c y va a calcular la distancia a su plaza asociada por orden, es decir uno a uno.

Entonces el siguiente paso es tener un dataframe que no sólo tenga el index de la plaza más cercana a cada radio sino tener la información geográfica (especialmente la columna geometry) para poder luego calcular la distancia propiamente dicha.

Vamos a traer la información de las plazas asociada al resultado que tuvimos con `st_nearest_feature()`.

```{r, echo=TRUE, message=FALSE}
plazas_c[st_nearest_feature(radios_c, plazas_c),][1:5]

nrow(plazas_c[st_nearest_feature(radios_c, plazas_c),])
```

Presten atención a la longitud de filas que devuelve este filtro, es 3554, la misma cantidad de observaciones que radios_c. Si bien estamos usando el dataframe plazas_c lo que le pedimos a R es que traiga los valores asociados sobre la función `st_nearest_feature`, que devolvía para cada index de radios_c el index de plaza_c más cercana. Asi el index = 1 del df de radios tiene como plaza más cercana al primer valor del calculo reciente (el index 283 de plazas, el object_id = 17, la plaza Canadá).

Perfecto, ya tenemos un nuevo dataframe de plazas cercanas a los radios el cual está ordenado de modo tal que el primer elemento de radios_c tiene como plaza más cercana al resultado de este filtro. 

Lo que nos falta es saber la distancia en sí, lo cual hacemos con `st_distance`.
El primer elemento de la función es el punto de origen, en este caso el centroide del radio censal, y el segundo elemento es el centroide de la plaza más cercana, el cual obtuvimos en los pasos anteriores. Luego le decimos a R que aplique la función elemento por elemento, es decir que calcule la distancia del primer elemento de radios_c al primer elemento de `plazas_c[st_nearest_feature(radios_c, plazas_c),]`, que como sabemos es su plaza más cercana.

Veamos lo que devuelve esta función para 2 registros nada más.

```{r, echo=TRUE, message=FALSE}
st_distance(radios_c, plazas_c[st_nearest_feature(radios_c, plazas_c),], by_element = TRUE)[1:2]
```

Perfecto! Ya tenemos el listado con las distancias calculadas desde el centroide de los radios al centroide de las plazas!
Recordemos que el objetivo es hacer un choropleth map con la distancia de los radios a las plazas, y para eso necesitamos polígonos, no puntos. Necesitamos que los centroides de los radios vuelvan a ser polígonos.

Aca vamos a hacer un truquito. Como el largo del df de poligonos de radios es el mismo que el de los centroides (porque fue una transformación del primero) vamos a calcular las distancias entre el centroide de los radios y el de las plazas pero el resultado de esta operación lo vamos a agregar como columna en el dataframe de poligonos de radios censales.
Como tiene el mismo largo R ni se va a enterar y nos va a dejar agregarlo sin problema!

(Acá tengan un toque de paciencia!)

```{r, echo=TRUE, message=FALSE}
radios <- radios %>% #Tomamos de base el df poligonos de radios censales
  mutate(distancia=st_distance(radios_c, plazas_c[st_nearest_feature(radios_c, plazas_c),], by_element = TRUE)) %>% #Agregamos columna nueva con los valores del calculo de distancia entre centroidoes ;)
  mutate(distancia=as.numeric(distancia)) #Convertimos a número

```

Miremos como quedó el dataframe de radios.
```{r}
head(radios)
```

Excelente, tenemos una columna nueva (distancia) con un número que nos va a permitir hacer nuestro querido choropleth.

Al mapa directo entonces.

```{r, echo=TRUE, message=FALSE}
ggplot() + 
  geom_sf(data = radios, aes(fill = distancia), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "Distancia a plaza más cercana",
       subtitle = "Ciudad Autónoma de Buenos Aires",
       fill = "Distancia a plaza más cercana")+
  theme_void()
```

Genial!
Si queremos podemos quedarnos sólo con los radios censales que están a menos de 500 metros.

```{r, echo=TRUE, message=FALSE}
ggplot() + 
  geom_sf(data = filter(radios,distancia < 501), aes(fill = distancia), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "Radios censales a menos de 500 metros de una plaza",
       subtitle = "Ciudad Autónoma de Buenos Aires",
       fill = "Distancia a plaza más cercana")+
  theme_void()
```

Ok. Muy lindo el mapa pero ¿de cuántas personas estamos hablando?

```{r, echo=TRUE, message=FALSE}
radios %>% 
  st_drop_geometry() %>% 
  group_by(distancia > 500) %>% 
  summarise(total = sum(POBLACION),
            pct= total / sum(radios_c$POBLACION)) 

```

El 64% de la población de Buenos Aires está a menos de 500 metros de una plaza, mientras que el 36% no.

Por último podemos hacer un histograma para ver cómo se distribuye la distancia.

```{r}
ggplot(radios) +
  geom_histogram(aes(distancia))
```

Y lo podemos facetar por comuna...

```{r}
ggplot(radios) +
  geom_histogram(aes(distancia)) +
  facet_wrap(~COMUNA, scales="free_y")

```


# Repaso

Y asi llegamos al final de la segunda clase donde tuvimos un pantallazo de las operaciones espaciales más comúnes:

* Área -> st_area
* Perímetro -> st_length
* Intersección -> st_intersection
* Convertir polígonos en puntos -> st_point_on_surface
* Encontrar el objeto más cercano -> st_nearest_feature
* Distancia -> st_distance
